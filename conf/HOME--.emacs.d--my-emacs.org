:PROPERTIES:
:header-args:emacs-lisp: :noweb no-export :tangle yes
:END:
#+STARTUP: content

* About this file
This file gives a detailed description of my emacs configuration,
and moreover, thanks to the support for literate programming of org-mode,
it's executable.

The structure of this file is simply a serial of loosely coupled commands,
like all other people's emacs configuration. All dependencies are gathered
and placed at the beginning to retain an uniform set of names thoughout
the configuring. The same reason is also applied to helpers. All helper
functions have a name starting with 'my', and if it's only used in this file,
'my' is followed by '--', else '-'.

#+begin_src emacs-lisp
  (setq package-archives
        '(("gnu"    . "https://mirrors.tuna.tsinghua.edu.cn/elpa/gnu/")
          ("nongnu" . "https://mirrors.tuna.tsinghua.edu.cn/elpa/nongnu/")
          ("melpa"  . "https://mirrors.tuna.tsinghua.edu.cn/elpa/melpa/")))
  (package-initialize)
  <<dependencies>>
  <<helpers>>
#+end_src

* Package Management
I use the macro 'use-package' to manage packages,
which is distributed with Emacs from 29.1, including installing, configuring.

To automatically install the used packages, this option is enabled.
#+begin_src emacs-lisp
  (setq use-package-always-ensure t)
#+end_src

* Appearance
Here is some basic settings for a not disturbing looking.

#+begin_src emacs-lisp
  (tool-bar-mode -1)
  (set-scroll-bar-mode nil)
  (menu-bar-mode -1)
  (add-to-list 'default-frame-alist
  	     '(font . "DejaVu Sans Mono-17"))
  (setq project-mode-line t)
#+end_src

* Action
People believe that Emacs is a general purpose interface to
computing infrastructure rather than just an editor. It's correct
in some extent. Of course, Emacs can not compete a real operating system,
but for a limited set of actions, Emacs can do amazingly well.
Action here means "copying a file into a directory", "modifying some code", etc.

This file's main purpose is to explain the set of actions that I perform on Emacs,
and makes them more efficient.

** Activity
Related actions are usually taken in a common context, like renaming, deleting, moving
file in Windows' file explorer. Emacs's command and buffer is also such
an example, but sometimes we would like to have multiple cooperating buffers to
achieve some bigger objects. For example, using gdb to debug a C program
usually requires multiple buffers, one to show current state of the running program,
one to show referenced source code, one to instruct gdb, etc. Not only it involves
multiple buffers, but also it consists of a serial of commands to fully accomplish
its object.
I call such long lasting actions as activities, in contrast with commands in Emacs
that have immediate effect.

#+begin_src emacs-lisp :tangle no :noweb-ref helpers
  (defvar my-activities
    '(
      <<my activities>>
      ))

  (defun my-activityp (av)
    (not (not (member av my-activities))))
#+end_src

There's an activity for default behaviour when no activity specified.
#+begin_src emacs-lisp :tangle no :noweb-ref "my activities"
  emacs
#+end_src

Some mechanisms should be used to specify which activity is being taken. I use tab bar
for this task. Each tab has an activity attached. To take an activity means
work on a new tab, and that tab has the activity attached.

#+begin_src emacs-lisp
  (setq tab-bar-tab-hints t)
  (setq tab-bar-select-tab-modifiers '(control))
  (tab-bar-mode)
#+end_src

#+begin_src emacs-lisp :tangle no :noweb-ref helpers
  (defun my-tab-activity (tab-number)
    (let* ((tabs (funcall tab-bar-tabs-function))
  	 (tab-index (1- tab-number))
  	 (tab (nth tab-index tabs)))
      (alist-get 'my-activity tab 'emacs)))

  (defun my-current-activity (&optional tab-number)
    (interactive)
    (let ((av (my-tab-activity (or tab-number (1+ (tab-bar--current-tab-index))))))
      (message "The current activity: %s" (symbol-name av))))

  (defun my-take-activity (avn)
    "Start taking the activity in a new tab."
    (interactive
     (list (completing-read (format-prompt "The activity to take" "emacs")
  			  my-activities)))
    (tab-bar-new-tab)
    (tab-bar-rename-tab avn)
    (let ((av (intern avn))
  	(tab (tab-bar--current-tab-find)))
      (if (my-activityp av)
  	(progn
  	  <<initialization of |av| on |tab|>>
  	  )
        (user-error "No such activity: %s" avn))))
#+end_src

#+begin_src emacs-lisp :tangle no :noweb-ref "initialization of |av| on |tab|"
  (nconc tab `((my-activity . ,av)))
#+end_src

The context of activities consists of a set of buffers, a set of rules to display buffers,
a current state, some activity specific commands.

I will not assign each buffer a single activity, because different activities might
deal with same buffer at the same time. For example, if I regard editing source file
and debugging as two different activities, then which activity should I assign for
the source file both for editing and debuging?
So I decide to delay the determination of the set of buffers
involved in a particular activity to the time I really need to deal with the set.
Maybe to use ibuffer.

#+begin_src emacs-lisp
  (global-set-key (kbd "C-x C-b") 'ibuffer)
#+end_src

As for the set of rules to display buffers, a simple strategy is to customize
the displaying when the buffer satisfies some criteria and the current activity has
regulation on it. The following helper creates conditions for display-buffer-alist.

#+begin_src emacs-lisp :tangle no :noweb-ref helpers
  (defun my-current-activity-is (av)
    (lambda (b) (eq av (my-current-activity))))
#+end_src

The state of activities is limited to the ones desktop.el can save.

#+begin_src emacs-lisp
  (desktop-save-mode 1)
#+end_src

Beside this, some preparation can be done to get a comfortable state
before embarking on an activity.

#+begin_src emacs-lisp :tangle no :noweb-ref "initialization of |av| on |tab|"
  (let ((funcs
         (alist-get av
  		  `(
  		    <<init functions of activities>>
  		    ))))
    (dolist (f funcs)
      (funcall f)))
#+end_src

The default activity emacs are initialized to a single window displaying
buffer scratch.
#+begin_src emacs-lisp :tangle no :noweb-ref "init functions of activities"
  (emacs ,(lambda () (display-buffer "*scratch*" '(display-buffer-full-frame))))
#+end_src

** Searching and Editing
These two concepts are too closly binded to explain one while ignoring another.
You must know what to edit to define objects to search, and you must know
where the object is to perform an editing.

There's a general purpose framework to select a particular object
from a set of candidate. I introduce it here because it's used everywhere.

#+begin_src emacs-lisp
  (use-package helm
    :demand t
    :config
    (helm-mode 1)
    :bind
    (("M-x" . helm-M-x)
     ("C-x r b" . helm-filtered-bookmarks)
     ("C-x C-f" . helm-find-files)))
#+end_src

The following sections are named following a pattern of "SCOPE: TYPE OF OBJECT".

*** File: Plain Text
If the searching and the editing is limited in a single file,
I prefer vi's key bindings than Emacs's originals.

#+begin_src emacs-lisp
  (use-package evil
    :demand t
    :config
    (evil-mode 1)
    (evil-set-initial-state 'Info-mode 'emacs)
    (evil-set-initial-state 'dired-mode 'emacs)
    (evil-set-initial-state 'Man-mode 'emacs)
    (evil-set-initial-state 'xref--xref-buffer-mode 'emacs)
    (evil-set-initial-state 'help-mode 'emacs))
  (use-package evil-org
    :hook org-mode)
#+end_src

I sometimes input CJK characters.

chu_desk_add_dep(librime-dev)
#+begin_src emacs-lisp
  (use-package rime
    :custom
    (default-input-method "rime")
    (rime-disable-predicates
     '(rime-predicate-after-alphabet-char-p
       rime-predicate-prog-in-code-p)))
#+end_src

*** Project: Plain Text
I use project.el for this job.

- project-find-regexp (C-x p g)
- project-search
- project-query-replace-regexp (C-x p r)

*** Project: Source Code
It's convenient if we can go beyond plain text, and operate on the structure
of source code directly. LSP is good for this purpose.

#+begin_src emacs-lisp
  (use-package eglot
    :custom (eglot-extend-to-xref t)
    :config
    (add-to-list 'eglot-server-programs '(python-mode . ("uv" "run" "ruff" "server")))
    :bind (:map eglot-mode-map
  	      ("C-c h" . eldoc)
  	      ("C-c f" . xref-find-definitions))
    :hook
    ((c-mode . eglot-ensure)
     (c++-mode . eglot-ensure)
     (python-mode . eglot-ensure)
     (lean4-mode . eglot-ensure)))
#+end_src

*** Project: File
I use project.el for this job.

- project-find-file (C-x p f)
- project-dired (C-x p D)

*** Project: Git Repository

#+begin_src emacs-lisp
  (use-package magit)
#+end_src

*** File System: File
A shortcut to access the directory that contains all local repositories.

#+begin_src emacs-lisp
  (defun my--dired-reps ()
    (interactive)
    (dired (getenv "REPOSITORY_HOME")))

  (global-set-key (kbd "C-x c d") 'my--dired-reps)
#+end_src

#+begin_src emacs-lisp
  (setq dired-maybe-use-globstar t)
  (setq dired-listing-switches "-ahl")
  (setq dired-isearch-filenames t)
#+end_src

** Meta
This set of actions take effect on Emacs, like buffer, window, etc, which
can not be classified in previous chapters.

#+begin_src emacs-lisp
  (global-set-key (kbd "C-M-h") 'windmove-left)
  (global-set-key (kbd "C-M-j") 'windmove-down)
  (global-set-key (kbd "C-M-k") 'windmove-up)
  (global-set-key (kbd "C-M-l") 'windmove-right)
#+end_src
* Miscellaneous

#+begin_src emacs-lisp
  (setq org-confirm-babel-evaluate nil)
  (use-package python
    :config
    (org-babel-do-load-languages
     'org-babel-load-languages
     (cons '(python . t) org-babel-load-languages)))
#+end_src

* Bibliography
- [[https://karthinks.com/software/emacs-window-management-almanac/][The Emacs window management almanac]]
  
